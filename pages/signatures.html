<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signature Formatter</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#f8fafc;color:#0f172a;line-height:1.6;}
        .container{max-width:1200px;margin:0 auto;padding:3rem 2rem;min-height:100vh}
        .header{margin-bottom:3rem;display:flex;align-items:flex-start;justify-content:space-between;gap:2rem;}
        .header-buttons{display:flex;align-items:center;flex-shrink:0;gap:1rem;}
        .header>div:first-child{flex:1;}
        .title{font-size:3rem;font-weight:700;background:linear-gradient(135deg,#4f46e5,#7c3aed);-webkit-background-clip:text;background-clip:text;color:transparent;margin-bottom:.75rem;line-height:1.1;}
        .subtitle{color:#64748b;font-size:1.25rem;max-width:700px;line-height:1.5;margin:0;}
        .home-link{background:#e2e8f0;border:none;padding:.875rem 1.5rem;border-radius:1.5rem;font-weight:500;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;gap:10px;text-decoration:none;color:inherit;font-size:1rem;flex-shrink:0;}
        .home-link:hover{background:#cbd5e1;transform:translateY(-1px)}
        .kofi-btn{background:#4f46e5;border:none;padding:.875rem;border-radius:1.5rem;font-weight:500;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;justify-content:center;text-decoration:none;color:#fff;font-size:1rem;width:50px;height:50px;position:relative;flex-shrink:0;}
        .kofi-btn:hover{background:#3730a3;transform:translateY(-1px);color:#fff}
        :root{--border:rgba(226,232,240,.7);--muted:#64748b;--accent:#4f46e5;}
        .card{background:#fff;border:1px solid var(--border);border-radius:1.25rem;padding:2.5rem;box-shadow:0 4px 6px rgba(0,0,0,.07);margin-bottom:2rem;}
        .card-desc{font-size:1.1rem;color:#64748b;margin-bottom:2.5rem;text-align:center;max-width:800px;margin-left:auto;margin-right:auto;}
        .editor-container{margin-bottom:2.5rem}
        .visual-editor{background:#fff;border:1px solid var(--border);border-radius:14px;padding:24px 30px;font-family:inherit;font-size:1.1rem;transition:all .2s ease;width:100%;color:#0f172a;min-height:250px;line-height:1.4;outline:none;overflow-y:auto;}
        .visual-editor:focus{outline:2px solid rgba(79,70,229,.5);outline-offset:2px;border-color:var(--accent);}
        .visual-editor:empty:before{content:'Start typing here... Select text to format it!';color:#94a3b8;font-style:italic;font-size:1.1rem;}
        .visual-editor img{max-width:100%;height:auto;display:block;margin:2px 0;border:1px solid #e2e8f0;border-radius:10px;}
        .selection-info{background:#f0f9ff;border:1px solid #bae6fd;border-radius:10px;padding:1.25rem;margin-bottom:2.5rem;font-size:0.95rem;color:#0369a1;}
        .generate-btn{background:linear-gradient(135deg,#4f46e5,#7c3aed);border:none;padding:1.25rem 2.5rem;border-radius:14px;font-weight:600;cursor:pointer;transition:all 0.2s ease;font-size:1.2rem;color:#fff;width:100%;margin-bottom:2.5rem;display:flex;align-items:center;justify-content:center;gap:1rem;}
        .generate-btn:hover{background:linear-gradient(135deg,#3730a3,#6d28d9);transform:translateY(-2px);box-shadow:0 12px 30px rgba(79,70,229,0.3);}
        .toolbar{background:#f8fafc;border:1px solid var(--border);border-radius:14px;padding:1.5rem;margin-bottom:2.5rem;display:grid;gap:1.25rem;}
        .toolbar-row{display:flex;gap:1.25rem;align-items:stretch;flex-wrap:wrap;}
        .toolbar-group{display:flex;align-items:center;gap:0.6rem;padding:0.75rem 1rem;border-radius:10px;background:#fff;border:1px solid rgba(226,232,240,.5);min-height:56px;box-shadow:0 1px 3px rgba(0,0,0,0.05);}
        .toolbar-group.full-width{width:100%;justify-content:space-between;overflow-x:auto;flex-wrap:wrap;gap:1rem;}
        .toolbar-btn{background:#fff;border:1px solid var(--border);border-radius:8px;padding:0.75rem 1.25rem;cursor:pointer;transition:all 0.2s ease;font-weight:500;font-size:0.9rem;white-space:nowrap;min-height:44px;display:flex;align-items:center;justify-content:center;}
        .toolbar-btn:hover{background:#f1f5f9;border-color:var(--accent);transform:translateY(-1px);}
        .toolbar-btn.active{background:var(--accent);color:#fff;border-color:var(--accent);box-shadow:0 2px 4px rgba(79,70,229,0.2);}
        .color-input{width:44px;height:44px;border:2px solid var(--border);border-radius:8px;cursor:pointer;transition:all 0.2s ease;}
        .color-input:hover{border-color:var(--accent);transform:scale(1.05);}
        .hex-input{border:1px solid var(--border);border-radius:8px;padding:0.75rem;background:#fff;font-size:0.9rem;width:85px;text-transform:uppercase;font-family:monospace;min-height:44px;}
        .url-input{border:1px solid var(--border);border-radius:8px;padding:0.75rem;background:#fff;font-size:0.9rem;width:200px;min-height:44px;}
        .size-select,.font-select,.symbol-select{border:1px solid var(--border);border-radius:8px;padding:0.75rem;background:#fff;cursor:pointer;font-size:0.9rem;min-height:44px;}
        .size-select{min-width:110px;} .font-select{min-width:140px;} .symbol-select{min-width:160px;}
        .size-select.compact{min-width:80px;padding:0.6rem;} .font-select.compact{min-width:100px;padding:0.6rem;} .toolbar-btn.compact{padding:0.6rem 1rem;font-size:0.85rem;}
        .symbol-search{border:1px solid var(--border);border-radius:8px;padding:0.75rem;background:#fff;font-size:0.9rem;width:130px;margin-right:0.75rem;min-height:44px;}
        .group-label{font-size:0.85rem;color:var(--muted);font-weight:600;margin-right:0.75rem;white-space:nowrap;text-transform:uppercase;letter-spacing:0.5px;}
        .color-controls{display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;}
        .recent-colors{display:flex;gap:0.75rem;flex-wrap:wrap;margin-top:0.75rem;}
        .recent-color{display:flex;flex-direction:column;align-items:center;gap:0.375rem;cursor:pointer;transition:all 0.2s ease;}
        .recent-color:hover{transform:scale(1.1);}
        .recent-color-swatch{width:30px;height:30px;border:2px solid var(--border);border-radius:6px;}
        .recent-color-hex{font-size:0.7rem;color:var(--muted);font-family:monospace;font-weight:500;}
        .swap-btn{background:#f8fafc;border:1px solid var(--border);border-radius:6px;padding:0.375rem;cursor:pointer;transition:all 0.2s ease;font-size:0.8rem;display:flex;align-items:center;justify-content:center;width:32px;height:32px;}
        .swap-btn:hover{background:#f1f5f9;border-color:var(--accent);transform:scale(1.1);}
        .bbcode-output-section{background:#fff;border:1px solid var(--border);border-radius:14px;padding:2.5rem;margin-top:2rem;}
        .bbcode-output{font-family:monospace;background:#f8fafc;border:1px solid #e2e8f0;border-radius:10px;padding:2rem;white-space:pre-wrap;word-wrap:break-word;font-size:1rem;line-height:1.6;min-height:140px;color:#64748b;font-style:italic;}
        .bbcode-output.has-content{color:#0f172a;font-style:normal;}
        .copy-btn{background:rgba(79,70,229,.1);border:1px solid rgba(79,70,229,.3);color:var(--accent);padding:1rem 2rem;border-radius:10px;font-size:1rem;cursor:pointer;margin-top:2rem;transition:all 0.2s ease;font-weight:500;}
        .copy-btn:hover{background:rgba(79,70,229,.2);transform:translateY(-2px);box-shadow:0 4px 12px rgba(79,70,229,0.2);}
        .copy-btn:disabled{opacity:0.5;cursor:not-allowed;}
        .footer{font-size:1rem;color:#94a3b8;border-top:1px solid rgba(226,232,240,.6);padding-top:2.5rem;margin-top:3rem;text-align:center;}
        @media (max-width:1024px){.container{padding:2rem 1.5rem;} .title{font-size:2.5rem;} .toolbar{padding:1.25rem;} .toolbar-row{gap:1rem;}}
        @media (max-width:768px){.header{flex-direction:column;gap:1.5rem;} .title{font-size:2rem;} .toolbar{padding:1rem;} .toolbar-row{flex-direction:column;align-items:stretch;} .format-row{flex-direction:row !important;} .format-group{flex-wrap:wrap !important;} .container{padding:1.5rem 1rem;} .url-input{width:160px;} .hex-input{width:70px;} .font-select{min-width:120px;} .symbol-select{min-width:140px;} .symbol-search{width:120px;}}
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div>
                <h1 class="title">Signature Formatter</h1>
                <p class="subtitle">Visual editor for signatures with letter-by-letter gradients that work in BBCode!</p>
            </div>
            <div class="header-buttons">
                <a href="https://ko-fi.com/melcodesstuff" class="kofi-btn" target="_blank">‚òï</a>
                <a href="https://melcodesstuff.github.io/pw/" class="home-link"><span>üè∞</span>Home</a>
            </div>
        </header>
        
        <div class="card">
            <p class="card-desc">Style text with formatting, colors, letter-by-letter gradients, fonts, and case options. Click "Generate BBCode" when you're ready!</p>

            <div class="editor-container">
                <div class="visual-editor" id="visualEditor" contenteditable="true" 
                    onmouseup="updateToolbarState()" onkeyup="updateToolbarState()" onkeydown="handleEnterKey(event)"></div>
            </div>

            <div class="selection-info" id="selectionInfo">üí° Tip: Select any text to format it, or click where you want to start typing with formatting</div>

            <div class="toolbar">
                <!-- Row 1: Combined Format & Layout -->
                <div class="toolbar-row">
                    <div class="toolbar-group">
                        <span class="group-label">Format:</span>
                        <button class="toolbar-btn" onclick="formatText('bold')" id="boldBtn"><strong>B</strong></button>
                        <button class="toolbar-btn" onclick="formatText('italic')" id="italicBtn"><em>I</em></button>
                        <button class="toolbar-btn" onclick="formatText('underline')" id="underlineBtn"><u>U</u></button>
                        <button class="toolbar-btn" onclick="formatText('strikeThrough')" id="strikeBtn"><s>S</s></button>
                        <select id="fontFamily" class="font-select compact" onchange="applyFontFamily()">
                            <option value="">Font</option>
                            <option value="Arial, sans-serif">Arial</option>
                            <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                            <option value="'Courier New', monospace">Courier New</option>
                            <option value="Georgia, serif">Georgia</option>
                            <option value="Helvetica, sans-serif">Helvetica</option>
                            <option value="Impact, sans-serif">Impact</option>
                            <option value="'Lucida Sans Unicode', sans-serif">Lucida Sans Unicode</option>
                            <option value="'Palatino Linotype', serif">Palatino</option>
                            <option value="Tahoma, sans-serif">Tahoma</option>
                            <option value="'Times New Roman', serif">Times New Roman</option>
                            <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                            <option value="Verdana, sans-serif">Verdana</option>
                        </select>
                        <select id="fontSize" class="size-select compact" onchange="applyFontSize()">
                            <option value="">Size</option>
                            <option value="8">8px</option><option value="10">10px</option><option value="12">12px</option>
                            <option value="14">14px</option><option value="16">16px</option><option value="18">18px</option>
                            <option value="20">20px</option><option value="24">24px</option><option value="28">28px</option>
                            <option value="32">32px</option>
                        </select>
                        <button class="toolbar-btn" onclick="formatText('justifyLeft')" id="leftBtn">‚¨ÖÔ∏è</button>
                        <button class="toolbar-btn" onclick="formatText('justifyCenter')" id="centerBtn">‚¨ÜÔ∏è</button>
                        <button class="toolbar-btn" onclick="formatText('justifyRight')" id="rightBtn">‚û°Ô∏è</button>
                        <button class="toolbar-btn compact" onclick="clearSelectedFormatting()">Clear</button>
                        <button class="toolbar-btn compact" onclick="clearAllFormatting()">Reset</button>
                    </div>
                </div>
            
                <!-- Row 2: Colors & Content -->
                <div class="toolbar-row">
                    <div class="toolbar-group">
                        <span class="group-label">Colors:</span>
                        <input type="text" id="hexInput" class="hex-input" placeholder="#000000" maxlength="7" oninput="updateColorFromHex()">
                        <input type="color" id="colorPicker" class="color-input" value="#000000" onchange="updateHexFromColor()">
                        <button class="toolbar-btn" onclick="applyTextColor()">üé® Apply</button>
                        <input type="text" id="gradientStartHex" class="hex-input" placeholder="#ff0000" maxlength="7" oninput="updateGradientStartFromHex()">
                        <input type="color" id="gradientStart" class="color-input" value="#ff0000" onchange="updateGradientStartHex()">
                        <button class="swap-btn" onclick="swapGradientColors()">‚áÑ</button>
                        <input type="text" id="gradientEndHex" class="hex-input" placeholder="#0000ff" maxlength="7" oninput="updateGradientEndFromHex()">
                        <input type="color" id="gradientEnd" class="color-input" value="#0000ff" onchange="updateGradientEndHex()">
                        <button class="toolbar-btn" onclick="applyGradient()">üåà Gradient</button>
                    </div>
        
                </div>
            
                <!-- Row 3: Recent Colors -->
                <div class="toolbar-row">
                    <div class="toolbar-group full-width">
                        <span class="group-label">Recent:</span>
                        <div class="recent-colors" id="recentColors"></div>
                        <span style="font-size:0.75rem;color:var(--muted);margin-left:auto;">Click to reuse</span>
                    </div>
                </div>
            

            <div class="toolbar-group">
                <span class="group-label">Content:</span>
                <input type="text" id="imageUrl" class="url-input" placeholder="Image URL...">
                <button class="toolbar-btn" onclick="insertImage()">üñºÔ∏è Insert</button>
                <button class="toolbar-btn" onclick="insertPlaceholderImage()">üì∑ Placeholder</button>
                <input type="text" id="symbolSearch" class="symbol-search" placeholder="Search..." oninput="filterSymbols()">
                <select id="symbolPicker" class="symbol-select" onchange="insertSymbol()">
                    <option value="">Symbols...</option>
                    <optgroup label="‚ô• Hearts & Love">
                        <option value="‚ô•" data-keywords="heart love">‚ô• Heart</option>
                        <option value="‚ô°" data-keywords="heart love outline">‚ô° Heart Outline</option>
                    </optgroup>
                    <optgroup label="‚òÖ Stars">
                        <option value="‚òÖ" data-keywords="star">‚òÖ Star</option>
                        <option value="‚òÜ" data-keywords="star outline">‚òÜ Star Outline</option>
                        <option value="‚ú¶" data-keywords="star four point">‚ú¶ Four Point Star</option>
                    </optgroup>
                    <optgroup label="‚Üí Arrows">
                        <option value="‚Üí" data-keywords="arrow right">‚Üí Right Arrow</option>
                        <option value="‚Üê" data-keywords="arrow left">‚Üê Left Arrow</option>
                        <option value="‚Üë" data-keywords="arrow up">‚Üë Up Arrow</option>
                        <option value="‚Üì" data-keywords="arrow down">‚Üì Down Arrow</option>
                    </optgroup>
                    <optgroup label="‚óÜ Shapes">
                        <option value="‚óè" data-keywords="circle black">‚óè Circle</option>
                        <option value="‚óã" data-keywords="circle outline">‚óã Circle Outline</option>
                        <option value="‚ñ†" data-keywords="square black">‚ñ† Square</option>
                        <option value="‚ñ°" data-keywords="square outline">‚ñ° Square Outline</option>
                    </optgroup>
                    <optgroup label="¬© Special">
                        <option value="¬©" data-keywords="copyright">¬© Copyright</option>
                        <option value="¬Æ" data-keywords="registered">¬Æ Registered</option>
                        <option value="‚Ñ¢" data-keywords="trademark">‚Ñ¢ Trademark</option>
                        <option value="¬∞" data-keywords="degree">¬∞ Degree</option>
                        <option value="‚Ä¢" data-keywords="bullet">‚Ä¢ Bullet</option>
                    </optgroup>
                </select>
            </div>
        </div>
            
            <button class="generate-btn" onclick="generateBBCode()">üöÄ Generate BBCode</button>

            <div class="bbcode-output-section">
                <h3 style="margin-bottom:1.5rem;font-size:1.1rem">BBCode Output</h3>
                <div class="bbcode-output" id="bbcodeOutput">Click "Generate BBCode" button above to convert your formatted text...</div>
                <button class="copy-btn" onclick="copyBBCode()" id="copyBtn" disabled>üìã Copy BBCode</button>
            </div>
        </div>
        
        <footer class="footer">
            <p>Unofficial Potterworld utilities ‚Ä¢ Made by ‚ú® mel for the community</p>
        </footer>
    </div>

    <script>
        let visualEditor = document.getElementById('visualEditor');
        let recentColors = [];
        
        function decodeHtmlEntities(text) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            return textarea.value;
        }

        function generateBBCode() {
            const htmlContent = visualEditor.innerHTML;
            if (!htmlContent.trim() || htmlContent === '<br>' || htmlContent === '<div><br></div>') {
                document.getElementById('bbcodeOutput').textContent = 'No content to convert. Please add some text first!';
                document.getElementById('bbcodeOutput').classList.remove('has-content');
                document.getElementById('copyBtn').disabled = true;
                return;
            }

            const bbcode = htmlToBBCode(htmlContent);
            const outputElement = document.getElementById('bbcodeOutput');
            
            if (bbcode && bbcode.trim()) {
                outputElement.textContent = bbcode;
                outputElement.classList.add('has-content');
                document.getElementById('copyBtn').disabled = false;
            } else {
                outputElement.textContent = 'No content to convert. Please add some text first!';
                outputElement.classList.remove('has-content');
                document.getElementById('copyBtn').disabled = true;
            }
        }

        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const newLine = document.createElement('div');
                    newLine.appendChild(document.createElement('br'));
                    range.deleteContents();
                    range.insertNode(newLine);
                    range.setStart(newLine, 0);
                    range.setEnd(newLine, 0);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
        }

        function formatText(command) {
            const selection = window.getSelection();
            
            // Handle alignment commands specially
            if (command.startsWith('justify')) {
                handleAlignment(command);
                return;
            }
            
            // Regular formatting commands
            document.execCommand(command, false, null);
            updateToolbarState();
            visualEditor.focus();
        }

        function handleAlignment(command) {
            const selection = window.getSelection();
            
            // Determine alignment style
            let alignStyle = 'left';
            if (command === 'justifyCenter') alignStyle = 'center';
            else if (command === 'justifyRight') alignStyle = 'right';
            
            if (selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed) {
                // Text is selected - wrap selection in alignment div
                const range = selection.getRangeAt(0);
                const selectedContent = range.extractContents();
                
                // Fix any images in the selection
                const images = selectedContent.querySelectorAll('img');
                images.forEach(img => {
                    if (alignStyle === 'center') {
                        img.style.display = 'block';
                        img.style.margin = '0px auto';
                    } else if (alignStyle === 'right') {
                        img.style.display = 'block';
                        img.style.margin = '10px 0 10px auto';
                    } else { // left
                        img.style.display = 'block';
                        img.style.margin = '10px auto 10px 0';
                    }
                });
                
                // Create alignment wrapper
                const alignDiv = document.createElement('div');
                alignDiv.style.textAlign = alignStyle;
                alignDiv.setAttribute('data-align', alignStyle);
                alignDiv.appendChild(selectedContent);
                
                range.insertNode(alignDiv);
                
                // Reselect the content to maintain selection and update toolbar
                range.selectNodeContents(alignDiv);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                // No selection - apply to current block or create new block
                let currentBlock = null;
                
                if (selection.rangeCount > 0) {
                    let node = selection.getRangeAt(0).startContainer;
                    
                    // If it's a text node, get its parent
                    if (node.nodeType === Node.TEXT_NODE) {
                        node = node.parentNode;
                    }
                    
                    // Find the current block element
                    while (node && node !== visualEditor) {
                        if (node.nodeType === Node.ELEMENT_NODE && 
                            (node.tagName === 'DIV' || node.tagName === 'P')) {
                            currentBlock = node;
                            break;
                        }
                        node = node.parentNode;
                    }
                }
                
                if (currentBlock && currentBlock !== visualEditor) {
                    // Apply alignment to existing block
                    currentBlock.style.textAlign = alignStyle;
                    currentBlock.setAttribute('data-align', alignStyle);
                    
                    // Fix any images in the block
                    const images = currentBlock.querySelectorAll('img');
                    images.forEach(img => {
                        if (alignStyle === 'center') {
                            img.style.display = 'block';
                            img.style.margin = '0px auto';
                        } else if (alignStyle === 'right') {
                            img.style.display = 'block';
                            img.style.margin = '10px 0 10px auto';
                        } else { // left
                            img.style.display = 'block';
                            img.style.margin = '10px auto 10px 0';
                        }
                    });
                } else {
                    // Create new aligned block at cursor position
                    const range = selection.getRangeAt(0);
                    const alignDiv = document.createElement('div');
                    alignDiv.style.textAlign = alignStyle;
                    alignDiv.setAttribute('data-align', alignStyle);
                    alignDiv.innerHTML = '<br>';
                    
                    range.deleteContents();
                    range.insertNode(alignDiv);
                    
                    // Position cursor inside the new div
                    range.setStart(alignDiv, 0);
                    range.setEnd(alignDiv, 0);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            
            // Force update toolbar state
            setTimeout(() => updateToolbarState(), 10);
            visualEditor.focus();
        }

        function updateToolbarState() {
            const buttons = ['boldBtn', 'italicBtn', 'underlineBtn', 'strikeBtn'];
            const states = ['bold', 'italic', 'underline', 'strikeThrough'];
            
            buttons.forEach((btnId, i) => {
                const btn = document.getElementById(btnId);
                if (btn) btn.classList.toggle('active', document.queryCommandState(states[i]));
            });
            
            // Handle alignment buttons specially
            const selection = window.getSelection();
            let currentAlign = 'left'; // default
            
            if (selection.rangeCount > 0) {
                let node = selection.getRangeAt(0).startContainer;
                
                // If it's a text node, get its parent
                if (node.nodeType === Node.TEXT_NODE) {
                    node = node.parentNode;
                }
                
                // Walk up the DOM to find alignment
                while (node && node !== visualEditor && node !== document.body) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Check for data-align attribute first
                        const dataAlign = node.getAttribute('data-align');
                        if (dataAlign) {
                            currentAlign = dataAlign;
                            break;
                        }
                        
                        // Check for inline style alignment
                        if (node.style && node.style.textAlign) {
                            currentAlign = node.style.textAlign;
                            break;
                        }
                        
                        // Check for computed style alignment
                        const computed = window.getComputedStyle(node);
                        if (computed && computed.textAlign && 
                            computed.textAlign !== 'start' && 
                            computed.textAlign !== 'initial' && 
                            computed.textAlign !== '') {
                            currentAlign = computed.textAlign;
                            break;
                        }
                    }
                    node = node.parentNode;
                }
            }
            
            // Update alignment buttons
            const leftBtn = document.getElementById('leftBtn');
            const centerBtn = document.getElementById('centerBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // Reset all alignment buttons
            if (leftBtn) leftBtn.classList.remove('active');
            if (centerBtn) centerBtn.classList.remove('active');
            if (rightBtn) rightBtn.classList.remove('active');
            
            // Set active button based on current alignment
            if (currentAlign === 'center') {
                if (centerBtn) centerBtn.classList.add('active');
            } else if (currentAlign === 'right') {
                if (rightBtn) rightBtn.classList.add('active');
            } else {
                if (leftBtn) leftBtn.classList.add('active');
            }
        }

        function applyTextColor() {
            const hexValue = document.getElementById('hexInput').value;
            const colorValue = document.getElementById('colorPicker').value;
            let color = colorValue;
            if (hexValue && /^#[0-9A-F]{6}$/i.test(hexValue)) {
                color = hexValue;
            }
            addToRecentColors(color);
            document.execCommand('foreColor', false, color);
            visualEditor.focus();
        }

        function interpolateColor(color1, color2, factor) {
            const hex1 = color1.replace('#', '');
            const hex2 = color2.replace('#', '');
            
            const r1 = parseInt(hex1.substring(0, 2), 16);
            const g1 = parseInt(hex1.substring(2, 4), 16);
            const b1 = parseInt(hex1.substring(4, 6), 16);
            
            const r2 = parseInt(hex2.substring(0, 2), 16);
            const g2 = parseInt(hex2.substring(2, 4), 16);
            const b2 = parseInt(hex2.substring(4, 6), 16);
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function applyGradient() {
            const startColor = document.getElementById('gradientStart').value;
            const endColor = document.getElementById('gradientEnd').value;
            const selection = window.getSelection();
            
            if (!selection.rangeCount || selection.getRangeAt(0).collapsed) {
                alert('Please select some text first to apply a gradient.');
                return;
            }
            
            const range = selection.getRangeAt(0);
            const plainText = range.toString();
            const allLetters = plainText.replace(/\s/g, '');
            
            if (!allLetters.trim()) {
                alert('Please select some text first to apply a gradient.');
                return;
            }
            
            addToRecentColors(startColor);
            addToRecentColors(endColor);
            
            const selectedContents = range.extractContents();
            let letterIndex = 0;
            
            function processTextNode(textNode) {
                const text = textNode.textContent;
                const fragment = document.createDocumentFragment();
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const span = document.createElement('span');
                    span.textContent = char;
                    
                    if (char.trim()) {
                        const factor = allLetters.length > 1 ? letterIndex / (allLetters.length - 1) : 0;
                        const interpolatedColor = interpolateColor(startColor, endColor, factor);
                        span.style.color = interpolatedColor;
                        span.setAttribute('data-gradient-letter', interpolatedColor);
                        letterIndex++;
                    }
                    fragment.appendChild(span);
                }
                return fragment;
            }
            
            const walker = document.createTreeWalker(selectedContents, NodeFilter.SHOW_TEXT, null, false);
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) textNodes.push(node);
            
            textNodes.forEach(textNode => {
                if (textNode.textContent.trim()) {
                    const processedFragment = processTextNode(textNode);
                    textNode.parentNode.replaceChild(processedFragment, textNode);
                }
            });
            
            range.insertNode(selectedContents);
            visualEditor.focus();
        }

        function filterSymbols() {
            const searchTerm = document.getElementById('symbolSearch').value.toLowerCase();
            const symbolPicker = document.getElementById('symbolPicker');
            const options = symbolPicker.querySelectorAll('option');
            const optgroups = symbolPicker.querySelectorAll('optgroup');
            
            if (!searchTerm) {
                options.forEach(option => option.style.display = '');
                optgroups.forEach(group => group.style.display = '');
                return;
            }
            
            optgroups.forEach(group => group.style.display = 'none');
            
            options.forEach(option => {
                if (option.value === '') {
                    option.style.display = '';
                    return;
                }
                
                const keywords = option.dataset.keywords || '';
                const text = option.textContent.toLowerCase();
                const matches = keywords.includes(searchTerm) || text.includes(searchTerm) || option.value.includes(searchTerm);
                
                if (matches) {
                    option.style.display = '';
                    const parentGroup = option.closest('optgroup');
                    if (parentGroup) parentGroup.style.display = '';
                } else {
                    option.style.display = 'none';
                }
            });
        }

        function insertSymbol() {
            const symbol = document.getElementById('symbolPicker').value;
            if (symbol) {
                visualEditor.focus();
                const selection = window.getSelection();
                
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    range.deleteContents();
                    const textNode = document.createTextNode(symbol);
                    range.insertNode(textNode);
                    range.setStartAfter(textNode);
                    range.setEndAfter(textNode);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                setTimeout(() => document.getElementById('symbolPicker').value = '', 100);
            }
        }

        function applyFontFamily() {
            const fontFamily = document.getElementById('fontFamily').value;
            if (fontFamily) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed) {
                    const span = document.createElement('span');
                    span.style.fontFamily = fontFamily;
                    span.setAttribute('data-font-family', fontFamily);
                    
                    const range = selection.getRangeAt(0);
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    
                    // Reselect the content to maintain selection
                    range.selectNodeContents(span);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Reset dropdown and update toolbar
                    setTimeout(() => {
                        document.getElementById('fontFamily').value = '';
                        updateToolbarState();
                    }, 100);
                } else {
                    alert('Please select some text first to change its font.');
                    document.getElementById('fontFamily').value = '';
                }
            }
            visualEditor.focus();
        }

        function applyFontSize() {
            const size = document.getElementById('fontSize').value;
            if (size) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed) {
                    const span = document.createElement('span');
                    span.style.fontSize = size + 'px';
                    span.setAttribute('data-font-size', size);
                    
                    const range = selection.getRangeAt(0);
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    
                    // Reselect the content to maintain selection
                    range.selectNodeContents(span);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Reset dropdown and update toolbar
                    setTimeout(() => {
                        document.getElementById('fontSize').value = '';
                        updateToolbarState();
                    }, 100);
                } else {
                    alert('Please select some text first to change its size.');
                    document.getElementById('fontSize').value = '';
                }
            }
            visualEditor.focus();
        }

        function insertImage() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) {
                alert('Please enter an image URL first.');
                return;
            }

            const img = document.createElement('img');
            img.src = url;
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.style.display = 'block';
            img.style.margin = '1px auto 1px 0';
            img.style.border = '1px solid #e2e8f0';
            img.style.borderRadius = '8px';
            
            img.onerror = function() {
                alert('Failed to load image. Please check the URL.');
                this.remove();
            };

            visualEditor.focus();
            const selection = window.getSelection();
            let range = selection.rangeCount > 0 ? selection.getRangeAt(0) : document.createRange();
            if (!selection.rangeCount) {
                range.selectNodeContents(visualEditor);
                range.collapse(false);
            }
            
            range.deleteContents();
            range.insertNode(img);
            
            const newLine = document.createElement('div');
            newLine.innerHTML = '<br>';
            range.setStartAfter(img);
            range.insertNode(newLine);
            range.setStart(newLine, 0);
            range.setEnd(newLine, 0);
            selection.removeAllRanges();
            selection.addRange(range);

            document.getElementById('imageUrl').value = '';
        }

        function insertPlaceholderImage() {
            const placeholderUrl = 'https://placehold.co/500x200';
            
            const img = document.createElement('img');
            img.src = placeholderUrl;
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.style.display = 'block';
            img.style.margin = '1px auto 1px 0';
            img.style.border = '1px solid #e2e8f0';
            img.style.borderRadius = '8px';
            
            img.onerror = function() {
                alert('Failed to load placeholder image.');
                this.remove();
            };

            visualEditor.focus();
            const selection = window.getSelection();
            let range = selection.rangeCount > 0 ? selection.getRangeAt(0) : document.createRange();
            if (!selection.rangeCount) {
                range.selectNodeContents(visualEditor);
                range.collapse(false);
            }
            
            range.deleteContents();
            range.insertNode(img);
            
            const newLine = document.createElement('div');
            newLine.innerHTML = '<br>';
            range.setStartAfter(img);
            range.insertNode(newLine);
            range.setStart(newLine, 0);
            range.setEnd(newLine, 0);
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function clearAllFormatting() {
            const allText = visualEditor.innerText || visualEditor.textContent || '';
            visualEditor.innerHTML = allText ? allText.replace(/\n/g, '<br>') : '<br>';
            visualEditor.focus();
        }

        function clearSelectedFormatting() {
            const selection = window.getSelection();
            if (!selection.rangeCount || selection.getRangeAt(0).collapsed) {
                alert('Please select some text first to remove formatting from it.');
                return;
            }
            document.execCommand('removeFormat');
            visualEditor.focus();
        }

        async function copyBBCode() {
            const bbcode = document.getElementById('bbcodeOutput').textContent;
            if (bbcode === 'Click "Generate BBCode" button above to convert your formatted text...') return;

            try {
                await navigator.clipboard.writeText(bbcode);
                const btn = document.querySelector('.copy-btn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                setTimeout(() => btn.textContent = originalText, 2000);
            } catch (err) {
                const textArea = document.createElement('textarea');
                textArea.value = bbcode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('BBCode copied to clipboard!');
            }
        }

        function updateColorFromHex() {
            const hex = document.getElementById('hexInput').value;
            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                document.getElementById('colorPicker').value = hex.toLowerCase();
            }
        }

        function updateHexFromColor() {
            document.getElementById('hexInput').value = document.getElementById('colorPicker').value.toUpperCase();
        }

        function updateGradientStartFromHex() {
            const hex = document.getElementById('gradientStartHex').value;
            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                document.getElementById('gradientStart').value = hex.toLowerCase();
            }
        }

        function updateGradientStartHex() {
            document.getElementById('gradientStartHex').value = document.getElementById('gradientStart').value.toUpperCase();
        }

        function updateGradientEndFromHex() {
            const hex = document.getElementById('gradientEndHex').value;
            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                document.getElementById('gradientEnd').value = hex.toLowerCase();
            }
        }

        function updateGradientEndHex() {
            document.getElementById('gradientEndHex').value = document.getElementById('gradientEnd').value.toUpperCase();
        }

        function swapGradientColors() {
            const startHex = document.getElementById('gradientStartHex').value;
            const startColor = document.getElementById('gradientStart').value;
            const endHex = document.getElementById('gradientEndHex').value;
            const endColor = document.getElementById('gradientEnd').value;
            
            document.getElementById('gradientStartHex').value = endHex;
            document.getElementById('gradientStart').value = endColor;
            document.getElementById('gradientEndHex').value = startHex;
            document.getElementById('gradientEnd').value = startColor;
        }

        function addToRecentColors(color) {
            if (!color.startsWith('#')) color = '#' + color;
            color = color.toUpperCase();
            
            recentColors = recentColors.filter(c => c !== color);
            recentColors.unshift(color);
            
            if (recentColors.length > 8) {
                recentColors = recentColors.slice(0, 8);
            }
            
            updateRecentColorsDisplay();
        }

        function updateRecentColorsDisplay() {
            const container = document.getElementById('recentColors');
            container.innerHTML = '';
            
            recentColors.forEach(color => {
                const recentColor = document.createElement('div');
                recentColor.className = 'recent-color';
                recentColor.onclick = () => applyRecentColor(color);
                
                const swatch = document.createElement('div');
                swatch.className = 'recent-color-swatch';
                swatch.style.backgroundColor = color;
                
                const hex = document.createElement('div');
                hex.className = 'recent-color-hex';
                hex.textContent = color;
                
                recentColor.appendChild(swatch);
                recentColor.appendChild(hex);
                container.appendChild(recentColor);
            });
        }

        function applyRecentColor(color) {
            document.getElementById('hexInput').value = color;
            document.getElementById('colorPicker').value = color.toLowerCase();
            applyTextColor();
        }

        // *** FIXED htmlToBBCode function ***
        function htmlToBBCode(html) {
            let bbcode = html;
            
            // FIRST: Decode HTML entities before any other processing
            bbcode = decodeHtmlEntities(bbcode);
            
            // Handle images first
            bbcode = bbcode.replace(/<img[^>]*src="([^"]*)"[^>]*>/gi, '[img]$1[/img]');
            
            // Handle gradient letters (most specific)
            bbcode = bbcode.replace(/<span[^>]*data-gradient-letter="([^"]*)"[^>]*>([^<]*)<\/span>/gi, '[color=$1]$2[/color]');
            
            // Handle font formatting with data attributes
            bbcode = bbcode.replace(/<span[^>]*data-font-family="([^"]*)"[^>]*>(.*?)<\/span>/gi, function(match, fontFamily, text) {
                const fontMap = {
                    'Arial, sans-serif': 'Arial',
                    "'Comic Sans MS', cursive": 'Comic Sans MS',
                    "'Courier New', monospace": 'Courier New',
                    'Georgia, serif': 'Georgia',
                    'Helvetica, sans-serif': 'Helvetica',
                    'Impact, sans-serif': 'Impact',
                    "'Lucida Sans Unicode', sans-serif": 'Lucida Sans Unicode',
                    "'Palatino Linotype', serif": 'Palatino',
                    'Tahoma, sans-serif': 'Tahoma',
                    "'Times New Roman', serif": 'Times New Roman',
                    "'Trebuchet MS', sans-serif": 'Trebuchet MS',
                    'Verdana, sans-serif': 'Verdana'
                };
                const simpleName = fontMap[fontFamily] || fontFamily.replace(/['"]/g, '');
                return `[font=${simpleName}]${text}[/font]`;
            });
            
            bbcode = bbcode.replace(/<span[^>]*data-font-size="([^"]*)"[^>]*>(.*?)<\/span>/gi, '[size=$1]$2[/size]');
            bbcode = bbcode.replace(/<span style="font-size:\s*(\d+)px[^"]*"[^>]*>(.*?)<\/span>/gi, '[size=$1]$2[/size]');
            
            // Handle inline formatting that might not have data attributes
            bbcode = bbcode.replace(/<span style="font-family:\s*([^;"]+)[^"]*"[^>]*>(.*?)<\/span>/gi, function(match, fontFamily, text) {
                const fontMap = {
                    'Arial': 'Arial',
                    'Arial, sans-serif': 'Arial',
                    'Comic Sans MS': 'Comic Sans MS',
                    "'Comic Sans MS', cursive": 'Comic Sans MS',
                    'Courier New': 'Courier New',
                    "'Courier New', monospace": 'Courier New',
                    'Georgia': 'Georgia',
                    'Georgia, serif': 'Georgia',
                    'Helvetica': 'Helvetica',
                    'Helvetica, sans-serif': 'Helvetica',
                    'Impact': 'Impact',
                    'Impact, sans-serif': 'Impact',
                    'Lucida Sans Unicode': 'Lucida Sans Unicode',
                    "'Lucida Sans Unicode', sans-serif": 'Lucida Sans Unicode',
                    'Palatino Linotype': 'Palatino',
                    "'Palatino Linotype', serif": 'Palatino',
                    'Tahoma': 'Tahoma',
                    'Tahoma, sans-serif': 'Tahoma',
                    'Times New Roman': 'Times New Roman',
                    "'Times New Roman', serif": 'Times New Roman',
                    'Trebuchet MS': 'Trebuchet MS',
                    "'Trebuchet MS', sans-serif": 'Trebuchet MS',
                    'Verdana': 'Verdana',
                    'Verdana, sans-serif': 'Verdana'
                };
                const cleanFont = fontFamily.replace(/['"]/g, '').split(',')[0].trim();
                const simpleName = fontMap[fontFamily] || fontMap[cleanFont] || cleanFont;
                return `[font=${simpleName}]${text}[/font]`;
            });
            
            // Basic formatting
            bbcode = bbcode.replace(/<strong[^>]*>(.*?)<\/strong>/gi, '[b]$1[/b]');
            bbcode = bbcode.replace(/<b[^>]*>(.*?)<\/b>/gi, '[b]$1[/b]');
            bbcode = bbcode.replace(/<em[^>]*>(.*?)<\/em>/gi, '[i]$1[/i]');
            bbcode = bbcode.replace(/<i[^>]*>(.*?)<\/i>/gi, '[i]$1[/i]');
            bbcode = bbcode.replace(/<u[^>]*>(.*?)<\/u>/gi, '[u]$1[/u]');
            bbcode = bbcode.replace(/<s[^>]*>(.*?)<\/s>/gi, '[s]$1[/s]');
            bbcode = bbcode.replace(/<strike[^>]*>(.*?)<\/strike>/gi, '[s]$1[/s]');
            
            // Colors
            bbcode = bbcode.replace(/<span style="color:\s*([^;"]+)[^"]*"[^>]*>(.*?)<\/span>/gi, '[color=$1]$2[/color]');
            bbcode = bbcode.replace(/<font color="([^"]*)"[^>]*>(.*?)<\/font>/gi, '[color=$1]$2[/color]');
            
            // *** FIX: Handle alignment BEFORE removing div tags ***
            // Handle individual aligned div elements with data-align attribute
            bbcode = bbcode.replace(/<div[^>]*data-align="(center|left|right)"[^>]*>(.*?)<\/div>/gi, function(match, align, content) {
                // Process the content inside the div recursively to handle nested formatting
                let processedContent = content.replace(/<br[^>]*>/gi, '\n');
                processedContent = processedContent.replace(/^\s+|\s+$/g, ''); // trim
                if (processedContent) {
                    return `[${align}]${processedContent}[/${align}]`;
                }
                return '';
            });
            
            // Handle aligned div elements with style attribute
            bbcode = bbcode.replace(/<div[^>]*style="[^"]*text-align:\s*(center|left|right)[^"]*"[^>]*>(.*?)<\/div>/gi, function(match, align, content) {
                // Process the content inside the div
                let processedContent = content.replace(/<br[^>]*>/gi, '\n');
                processedContent = processedContent.replace(/^\s+|\s+$/g, ''); // trim
                if (processedContent) {
                    return `[${align}]${processedContent}[/${align}]`;
                }
                return '';
            });
            
            // Handle structural elements that create line breaks
            bbcode = bbcode.replace(/<br[^>]*>/gi, '\n');
            bbcode = bbcode.replace(/([^>])<div[^>]*>/gi, '$1\n');
            bbcode = bbcode.replace(/<\/div>\s*<div[^>]*>/gi, '\n');
            
            // Remove remaining div tags (after alignment processing)
            bbcode = bbcode.replace(/<\/?div[^>]*>/gi, '');
            
            // Clean up any remaining HTML
            bbcode = bbcode.replace(/<[^>]*>/g, '');
            
            // Clean up whitespace
            bbcode = bbcode.replace(/^\s+/, '');
            bbcode = bbcode.replace(/\s+$/, '');
            bbcode = bbcode.replace(/[ \t]+/g, ' ');
            bbcode = bbcode.replace(/\n{3,}/g, '\n\n');
            
            // Clean up empty formatting tags
            bbcode = bbcode.replace(/\[b\]\[\/b\]|\[i\]\[\/i\]|\[u\]\[\/u\]|\[s\]\[\/s\]/g, '');
            bbcode = bbcode.replace(/\[font=[^\]]*\]\[\/font\]|\[size=[^\]]*\]\[\/size\]|\[color=[^\]]*\]\[\/color\]/g, '');
            bbcode = bbcode.replace(/\[center\]\[\/center\]|\[left\]\[\/left\]|\[right\]\[\/right\]/g, '');
            
            // Clean up empty lines within alignment tags
            bbcode = bbcode.replace(/\[(center|left|right)\]\s*\n+\s*\[\/\1\]/g, '');
            
            // Consolidate adjacent same formatting
            bbcode = bbcode.replace(/\[\/b\]\[b\]/g, '');
            bbcode = bbcode.replace(/\[\/i\]\[i\]/g, '');
            bbcode = bbcode.replace(/\[\/u\]\[u\]/g, '');
            bbcode = bbcode.replace(/\[\/s\]\[s\]/g, '');
            
            // Consolidate adjacent same alignment
            bbcode = bbcode.replace(/\[\/center\]\s*\[center\]/g, '\n');
            bbcode = bbcode.replace(/\[\/left\]\s*\[left\]/g, '\n');
            bbcode = bbcode.replace(/\[\/right\]\s*\[right\]/g, '\n');
            
            return bbcode;
        }

        function bbcodeToHtml(bbcode) {
                    return bbcode
                        .replace(/\[img\](.*?)\[\/img\]/gi, '<div><img src="$1" style="max-width:100%;height:auto;display:block;margin:10px 0;border:1px solid #e2e8f0;border-radius:8px;"></div>')
                        .replace(/\[font=([^\]]*)\](.*?)\[\/font\]/gi, function(match, fontName, text) {
                            const fontMap = {
                                'Arial': 'Arial, sans-serif',
                                'Comic Sans MS': "'Comic Sans MS', cursive",
                                'Courier New': "'Courier New', monospace",
                                'Georgia': 'Georgia, serif',
                                'Helvetica': 'Helvetica, sans-serif',
                                'Impact': 'Impact, sans-serif',
                                'Lucida Sans Unicode': "'Lucida Sans Unicode', sans-serif",
                                'Palatino': "'Palatino Linotype', serif",
                                'Tahoma': 'Tahoma, sans-serif',
                                'Times New Roman': "'Times New Roman', serif",
                                'Trebuchet MS': "'Trebuchet MS', sans-serif",
                                'Verdana': 'Verdana, sans-serif'
                            };
                            const cssFont = fontMap[fontName] || fontName;
                            return `<span style="font-family:${cssFont}">${text}</span>`;
                        })
                        .replace(/\[b\](.*?)\[\/b\]/gi, '<strong>$1</strong>')
                        .replace(/\[i\](.*?)\[\/i\]/gi, '<em>$1</em>')
                        .replace(/\[u\](.*?)\[\/u\]/gi, '<u>$1</u>')
                        .replace(/\[s\](.*?)\[\/s\]/gi, '<s>$1</s>')
                        .replace(/\[color=([^\]]*)\](.*?)\[\/color\]/gi, '<span style="color:$1">$2</span>')
                        .replace(/\[size=([^\]]*)\](.*?)\[\/size\]/gi, '<span style="font-size:$1px">$2</span>')
                        .replace(/\[center\](.*?)\[\/center\]/gi, '<div style="text-align:center" data-align="center">$1</div>')
                        .replace(/\[left\](.*?)\[\/left\]/gi, '<div style="text-align:left" data-align="left">$1</div>')
                        .replace(/\[right\](.*?)\[\/right\]/gi, '<div style="text-align:right" data-align="right">$1</div>')
                        .replace(/\n/g, '<br>');
                }

        // Initialize
        visualEditor.focus();
        document.getElementById('hexInput').value = '#000000';
        document.getElementById('gradientStartHex').value = '#FF0000';
        document.getElementById('gradientEndHex').value = '#0000FF';
        
        // Initialize empty recent colors
        updateRecentColorsDisplay();
        
        // Handle paste events to process external formatting
        visualEditor.addEventListener('paste', function(e) {
            // Allow the paste to happen first
            setTimeout(() => {
                // Process any pasted content to ensure proper formatting
                const content = visualEditor.innerHTML;
                if (content) {
                    // Clean up any weird formatting from external sources
                    let cleaned = content;
                    
                    // Convert common external formatting patterns
                    cleaned = cleaned.replace(/<p[^>]*>/gi, '<div>');
                    cleaned = cleaned.replace(/<\/p>/gi, '</div>');
                    
                    // Fix nested formatting issues
                    cleaned = cleaned.replace(/<div[^>]*>\s*<\/div>/gi, '<div><br></div>');
                    
                    if (cleaned !== content) {
                        visualEditor.innerHTML = cleaned;
                    }
                }
            }, 10);
        });
        
        document.addEventListener('selectionchange', function() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                if (visualEditor.contains(range.commonAncestorContainer) || range.commonAncestorContainer === visualEditor) {
                    // Slight delay to ensure DOM is updated
                    setTimeout(updateToolbarState, 10);
                }
            }
        });
        
        document.getElementById('imageUrl').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                insertImage();
            }
        });
    </script>
</body>
</html>
